// Settings Page JavaScript

/**
 * Settings Manager Class
 * Handles all settings-related functionality for the extension
 */
class SettingsManager {
    constructor() {
        this.defaultSettings = {
            autoFillOnLoad: true,
            showVisualFeedback: true,
            debugMode: false,
            fillDelay: 500,
            autoNormalizeUrls: true,
            validateUrls: true,
            strictMode: true,
            caseSensitive: false,
            similarityThreshold: 0.8,
            autoGenerateDescriptions: true,
            overwriteUserChanges: false,
            defaultTemplate: 'auto',
            descriptionMinLength: 20,
            autoParseOnImport: true,
            showImportWarnings: true,
            importTimeout: 30,
            logLevel: 'info',
            cacheSize: 10,
            updateInterval: 5
        };

        // Bind methods to this instance
        this.initialize = this.initialize.bind(this);
        this.loadSettings = this.loadSettings.bind(this);
        this.saveSettings = this.saveSettings.bind(this);
        this.resetSettings = this.resetSettings.bind(this);
        this.exportData = this.exportData.bind(this);
        this.importData = this.importData.bind(this);
        this.cleanDuplicates = this.cleanDuplicates.bind(this);
        this.resetAllData = this.resetAllData.bind(this);
    }

    async initialize() {
        try {
            await this.loadSettings();
            this.setupEventListeners();
            this.setupSectionToggles();
            await this.loadStatistics();
            console.log('[SETTINGS] Settings page initialized successfully');
        } catch (error) {
            console.error('[SETTINGS] Error initializing settings:', error);
            this.showStatus('Error initializing settings', 'error');
        }
    }

    async loadSettings() {
        try {
            const { settings = {} } = await chrome.storage.sync.get('settings');
            const currentSettings = { ...this.defaultSettings, ...settings };
            this.applySettingsToUI(currentSettings);
            
            // Load LLM API key if present
            const { llmApiKey = '' } = await chrome.storage.sync.get('llmApiKey');
            const apiInput = document.getElementById('llmApiKey');
            if (apiInput) apiInput.value = llmApiKey;
            
            console.log('[SETTINGS] Settings loaded successfully');
        } catch (error) {
            console.error('[SETTINGS] Error loading settings:', error);
            this.showStatus('Error loading settings', 'error');
        }
    }

    applySettingsToUI(settings) {
        Object.entries(settings).forEach(([key, value]) => {
            const element = document.getElementById(key);
            if (!element) return;

            if (element.type === 'checkbox') {
                element.checked = value;
            } else if (element.type === 'range') {
                element.value = typeof value === 'number' ? value * 100 : value;
                this.updateRangeDisplay(element);
            } else if (element.type === 'number') {
                element.value = value;
            } else {
                element.value = value;
            }
        });
    }

    setupEventListeners() {
        // Save button
        document.getElementById('saveSettings')?.addEventListener('click', this.saveSettings);
        
        // Reset button
        document.getElementById('resetSettings')?.addEventListener('click', this.resetSettings);
        
        // Range inputs
        document.querySelectorAll('input[type="range"]').forEach(range => {
            range.addEventListener('input', () => this.updateRangeDisplay(range));
        });

        // All inputs for auto-save
        const debouncedSave = this.debounce(this.saveSettings, 1000);
        document.querySelectorAll('input, select, textarea').forEach(input => {
            input.addEventListener('change', debouncedSave);
        });
    }

    setupSectionToggles() {
        document.querySelectorAll('.section-header').forEach(header => {
            header.addEventListener('click', () => {
                const content = header.nextElementSibling;
                const toggle = header.querySelector('.section-toggle');
                if (content?.classList.contains('section-content')) {
                    content.classList.toggle('active');
                    toggle.textContent = content.classList.contains('active') ? '▼' : '▶';
                }
            });
        });
    }

    updateRangeDisplay(rangeElement) {
        const valueDisplay = rangeElement.nextElementSibling;
        if (valueDisplay?.classList.contains('range-value')) {
            valueDisplay.textContent = `${rangeElement.value}%`;
        }
    }

    async loadStatistics() {
        try {
            const storage = await chrome.storage.sync.get(null);
            
            this.updateStatistic('socialLinksCount', (storage.socialLinks || []).length);
            this.updateStatistic('universalFieldsCount', Object.keys(storage.universalFormData || {}).length);
            this.updateStatistic('servicesCount', Object.keys(storage.services || {}).length);
            
            const storageSize = new Blob([JSON.stringify(storage)]).size;
            this.updateStatistic('storageUsed', this.formatBytes(storageSize));
        } catch (error) {
            console.error('[SETTINGS] Error loading statistics:', error);
        }
    }

    updateStatistic(id, value) {
        const element = document.getElementById(id);
        if (element) element.textContent = value;
    }

    formatBytes(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    async saveSettings() {
        try {
            const settings = this.collectSettingsFromUI();
            await chrome.storage.sync.set({ settings });
            
            // Save LLM API key separately
            const apiInput = document.getElementById('llmApiKey');
            if (apiInput) {
                await chrome.storage.sync.set({ llmApiKey: apiInput.value?.trim() });
            }

            await chrome.runtime.sendMessage({
                type: 'SETTINGS_UPDATED',
                settings
            });

            this.showStatus('Settings saved successfully', 'success');
        } catch (error) {
            console.error('[SETTINGS] Error saving settings:', error);
            this.showStatus('Error saving settings', 'error');
        }
    }

    collectSettingsFromUI() {
        const settings = {};
        Object.keys(this.defaultSettings).forEach(key => {
            const element = document.getElementById(key);
            if (!element) return;

            if (element.type === 'checkbox') {
                settings[key] = element.checked;
            } else if (element.type === 'range') {
                settings[key] = parseFloat(element.value) / 100;
            } else if (element.type === 'number') {
                settings[key] = parseInt(element.value, 10);
            } else {
                settings[key] = element.value;
            }
        });
        return settings;
    }

    async resetSettings() {
        if (!confirm('Reset all settings to defaults?')) return;
        
        try {
            await chrome.storage.sync.set({ settings: this.defaultSettings });
            this.applySettingsToUI(this.defaultSettings);
            this.showStatus('Settings reset to defaults', 'success');
        } catch (error) {
            console.error('[SETTINGS] Error resetting settings:', error);
            this.showStatus('Error resetting settings', 'error');
        }
    }

    async exportData() {
        try {
            const data = await chrome.storage.sync.get(null);
            const blob = new Blob([JSON.stringify({
                timestamp: new Date().toISOString(),
                version: '1.0',
                data
            }, null, 2)], { type: 'application/json' });
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `social-filler-pro-backup-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);

            this.showStatus('Data exported successfully', 'success');
        } catch (error) {
            console.error('[SETTINGS] Error exporting data:', error);
            this.showStatus('Error exporting data', 'error');
        }
    }

    async importData(event) {
        const file = event.target.files[0];
        if (!file) return;

        try {
            const text = await file.text();
            const importData = JSON.parse(text);

            if (!importData.data) throw new Error('Invalid backup file');

            if (!confirm('This will overwrite all current data. Continue?')) return;

            await chrome.storage.sync.clear();
            await chrome.storage.sync.set(importData.data);
            await this.loadSettings();
            await this.loadStatistics();
            
            this.showStatus('Data imported successfully', 'success');
        } catch (error) {
            console.error('[SETTINGS] Error importing data:', error);
            this.showStatus('Error importing data: ' + error.message, 'error');
        }

        event.target.value = '';
    }

    async cleanDuplicates() {
        try {
            const cleanedCount = await window.DuplicatePrevention?.cleanupDuplicates() || 0;
            this.showStatus(`Cleaned ${cleanedCount} duplicates`, 'success');
            await this.loadStatistics();
        } catch (error) {
            console.error('[SETTINGS] Error cleaning duplicates:', error);
            this.showStatus('Error cleaning duplicates', 'error');
        }
    }

    async resetAllData() {
        if (!confirm('Delete ALL data? This cannot be undone!')) return;
        if (!confirm('Are you absolutely sure? ALL data will be permanently deleted.')) return;

        try {
            await chrome.storage.sync.clear();
            await this.loadSettings();
            await this.loadStatistics();
            this.showStatus('All data has been reset', 'success');
        } catch (error) {
            console.error('[SETTINGS] Error resetting data:', error);
            this.showStatus('Error resetting data', 'error');
        }
    }

    showStatus(message, type = 'info') {
        const status = document.getElementById('statusMessage');
        if (!status) return;

        status.textContent = message;
        status.className = `status-message status-${type}`;
        status.style.display = 'block';

        setTimeout(() => {
            status.style.display = 'none';
        }, 3000);
    }

    debounce(func, wait) {
        let timeout;
        return (...args) => {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }
}

// Global instance
const settingsManager = new SettingsManager();

// Global functions for HTML handlers
window.goBack = () => window.close();
window.toggleSection = (header) => {
    const content = header.nextElementSibling;
    const toggle = header.querySelector('.section-toggle');
    content.classList.toggle('active');
    toggle.textContent = content.classList.contains('active') ? '▼' : '▶';
};
window.saveSettings = () => settingsManager.saveSettings();
window.resetSettings = () => settingsManager.resetSettings();
window.exportData = () => settingsManager.exportData();
window.importData = (event) => settingsManager.importData(event);
window.cleanDuplicates = () => settingsManager.cleanDuplicates();
window.resetAllData = () => settingsManager.resetAllData();

// Initialize when page loads
document.addEventListener('DOMContentLoaded', () => settingsManager.initialize());